% Generated by roxygen2 (4.1.0): do not edit by hand
% Please edit documentation in R/SNPbin.R
\docType{class}
\name{genlight-class}
\alias{$,genlight-method}
\alias{$<-,genlight-method}
\alias{NA.posi}
\alias{NA.posi,genlight-method}
\alias{[,genlight,ANY,ANY-method}
\alias{[,genlight-method}
\alias{alleles,genlight-method}
\alias{alleles<-,genlight-method}
\alias{as,data.frame,genlight-method}
\alias{as,list,genlight-method}
\alias{as,matrix,genlight-method}
\alias{as.data.frame.genlight}
\alias{as.list.genlight}
\alias{as.matrix.genlight}
\alias{cbind.genlight}
\alias{chr}
\alias{chr,genlight-method}
\alias{chr<-}
\alias{chr<-,genlight-method}
\alias{chromosome}
\alias{chromosome,genlight-method}
\alias{chromosome<-}
\alias{chromosome<-,genlight-method}
\alias{coerce,data.frame,genlight-method}
\alias{coerce,list,genlight-method}
\alias{coerce,matrix,genlight-method}
\alias{genlight}
\alias{genlight-class}
\alias{indNames,genlight-method}
\alias{indNames<-,genlight-method}
\alias{initialize,genlight-method}
\alias{locNames,genlight-method}
\alias{locNames<-,genlight-method}
\alias{nInd,genlight-method}
\alias{nLoc,genlight-method}
\alias{names,genlight-method}
\alias{other,genlight-method}
\alias{other<-,genlight-method}
\alias{ploidy,genlight-method}
\alias{ploidy<-,genlight-method}
\alias{pop,genlight-method}
\alias{pop<-,genlight-method}
\alias{position}
\alias{position,genlight-method}
\alias{position<-}
\alias{position<-,genlight-method}
\alias{rbind.genlight}
\alias{show,genlight-method}
\title{Formal class "genlight"}
\description{
The class \code{genlight} is a formal (S4) class for storing a genotypes of
binary SNPs in a compact way, using a bit-level coding scheme.  This storage
is most efficient with haploid data, where the memory taken to represent
data can be reduced more than 50 times. However, \code{genlight} can be used
for any level of ploidy, and still remain an efficient storage mode.
}
\details{
A \code{genlight} object can be constructed from vectors of integers giving
the number of the second allele for each locus and each individual (see
'Objects of the class genlight' below).

\code{genlight} stores multiple genotypes. Each genotype is stored as a
\linkS4class{SNPbin} object.

=== On the subsetting using \code{[} ===

The function \code{[} accepts the following extra arguments: \describe{
\item{treatOther}{a logical stating whether elements of the \code{@other}
slot should be treated as well (TRUE), or not (FALSE). If treated, elements
of the list are examined for a possible match of length (vectors, lists) or
number of rows (matrices, data frames) with the number of individuals. Those
who match are subsetted accordingly. Others are left as is, issuing a
warning unless the argument \code{quiet} is set to TRUE.} \item{quiet}{a
logical indicating whether warnings should be issued when trying to subset
components of the \code{@other} slot which do not match the number of
individuals (TRUE), or not (FALSE, default). } \item{list()}{further
arguments passed to the genlight constructor.} }
}
\section{Objects from the class genlight}{
 \code{genlight} objects can be
created by calls to \code{new("genlight", ...)}, where '...' can be the
following arguments: \describe{ \item{list("gen")}{input genotypes, where
each genotype is coded as a vector of numbers of the second allele. If a
list, each slot of the list correspond to an individual; if a matrix or a
data.frame, rows correspond to individuals and columns to SNPs. If
individuals or loci are named in the input, these names will we stored in
the produced object. All individuals are expected to have the same number of
SNPs. Shorter genotypes are completed with NAs, issuing a warning.}
\item{list("ploidy")}{an optional vector of integers indicating the ploidy
of the genotypes. Genotypes can therefore have different ploidy. If not
provided, ploidy will be guessed from the data (as the maximum number of
second alleles in each individual).} \item{list("ind.names")}{an optional
vector of characters giving the labels of the genotypes.}
\item{list("loc.names")}{an optional vector of characters giving the labels
of the SNPs.} \item{list("loc.all")}{an optional vector of characters
indicating the alleles of each SNP; for each SNP, alleles must be coded by
two letters separated by '/', e.g. 'a/t' is valid, but 'a t' or 'a |t' are
not.} \item{list("chromosome")}{an optional factor indicating the chromosome
to which each SNP belongs.} \item{list("position")}{an optional vector of
integers indicating the position of the SNPs.} \item{list("other")}{an
optional list storing miscellaneous information.} }
}
\examples{
\dontrun{
## TOY EXAMPLE ##
## create and convert data
dat <- list(toto=c(1,1,0,0), titi=c(NA,1,1,0), tata=c(NA,0,3, NA))
x <- new("genlight", dat)
x

## examine the content of the object
names(x)
x@gen
x@gen[[1]]@snp # bit-level coding for first individual

## conversions
as.list(x)
as.matrix(x)

## round trips - must return TRUE
identical(x, new("genlight", as.list(x))) # list
identical(x, new("genlight", as.matrix(x))) # matrix
identical(x, new("genlight", as.data.frame(x))) # data.frame

## test subsetting
x[c(1,3)] # keep individuals 1 and 3
as.list(x[c(1,3)])
x[c(1,3), 1:2] # keep individuals 1 and 3, loci 1 and 2
as.list(x[c(1,3), 1:2])
x[c(TRUE,FALSE), c(TRUE,TRUE,FALSE,FALSE)] # same, using logicals
as.list(x[c(TRUE,FALSE), c(TRUE,TRUE,FALSE,FALSE)])


## REAL-SIZE EXAMPLE ##
## 50 genotypes of 1,000,000 SNPs
dat <- lapply(1:50, function(i) sample(c(0,1,NA), 1e6, prob=c(.5, .49, .01), replace=TRUE))
names(dat) <- paste("indiv", 1:length(dat))
print(object.size(dat), unit="aut") # size of the original data

x <- new("genlight", dat) # conversion
x
print(object.size(x), unit="au") # size of the genlight object
object.size(dat)/object.size(x) # conversion efficiency



#### cbind, rbind ####
a <- new("genlight", list(toto=rep(1,10), tata=rep(c(0,1), each=5), titi=c(NA, rep(1,9)) ))

ara <- rbind(a,a)
ara
as.matrix(ara)

aca <- cbind(a,a)
aca
as.matrix(aca)


#### subsetting @other ####
x <- new("genlight", list(a=1,b=0,c=1), other=list(1:3, letters,data.frame(2:4)))
x
other(x)
x[2:3]
other(x[2:3])
other(x[2:3, treatOther=FALSE])


#### seppop ####
pop(x) # no population info
pop(x) <- c("pop1","pop1", "pop2") # set population memberships
pop(x)
seppop(x)
}
}
\author{
Thibaut Jombart (\email{t.jombart@imperial.ac.uk})
}
\seealso{
Related class:\cr - \code{\linkS4class{SNPbin}}, for storing
individual genotypes of binary SNPs\cr

- \code{\linkS4class{genind}}, for storing other types of genetic markers.
\cr
}
\keyword{classes}

